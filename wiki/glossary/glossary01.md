## A
- **Algorithmus:** Folge von einfachen Anweisungen, die zusammen ein komplexeres Problem lösen.
- **Alpha Test:** *Testing* in einem frühen Stadium der Softwareentwicklung. *Bugs* sind ständig zu erwarten.
- **AND:** *Boolesche / Logische Operation*. Eine AND-Operation ergibt true, wenn beide Operanden true sind. Folglich: 1 AND 1 = 1. 1 AND 0 = 0, 0 AND 1 = 0, 0 AND 0 = 0.
- **Android:** Betriebssystem von Google, insbesondere für Mobilgeräte.

## B
- **Beta Test:** Phase zwischen *Alpha Test* und *Release* beim *Testing*. *Bugs* können auftreten, sollten aber kein ständiger Begleiter mehr sein. 
- **Binärsystem:** Zahlensystem basierend auf der Basis 2 (statt der Basis 10 in unserem normalen Dezimalsystem). Grundlage für jeden Computer.
- **Bit:** Die kleinste Informationseinheit. Kennt nur die Zustände 1 (oder true oder an) und 0 (oder false oder aus). Siehe *Binärsystem*. Moderne Computer sind 64-Bit-Rechner, die also mit 64 Bits gleichzeitig arbeiten (zum Beispiel bei Rechenoperationen).
- **Black Box Test:** Form des *Testing*, bei dem bewusst nicht auf den Code der zu testenden Komponente geschaut wird. Anforderungen werden aus Anwendersicht formuliert und es wird geprüft, ob diese Anforderungen erfüllt werden.
- **Boolean:** Variablentyp in den meisten Programmiersprachen. Entspricht einem Bit. Kann nur die Werte true oder false (1 oder 0) speichern.
- **Boolean Operation:** *Logische Operationen*, die Boolesche Ausdrücke (true / false) miteinander verknüpfen. Die wichtigsten sind: *AND*, *OR*, *EXOR*, *NOT*. In der Programmierung finden logische Operationen vor allem in Bedingungen statt.
- **Boolesche Variable:** Variable vom Typ *Boolean*.
- **Bug:** Fehler in einem Programm. Oft wird unterschieden zwischen *Syntaxfehlern* und *Logikfehlern*.
- **Byte:** Informationseinheit. Ein Byte entspricht 8 Bit, kann also die Werte von 0 bis 255 aufnehmen.
- **Bytecode:** Wichtige Zwischenstufe bei der Programmiersprache *JAVA*. *JAVA*-Rohcode wird zu Bytecode *kompiliert*. Dieser Bytecode ist, im Gegensatz zu dem kompilierten Code der meisten anderen Programmiersprachen noch nicht *plattform*spezifisch. Die *Java* *Runtime* Environment (*JRE*) übernimmer dann diesen 
Bytecode und fungiert als *Interpreter* für die jeweils spezifische *Plattform*. Der Bytecode ist aber schon erheblich näher an Maschinensprache als der JAVA-Rohcode. Insofern kann der *Interpreter* mit diesem Code besser / schneller arbeiten als in anderen *Interpretersprachen*. Java ist daher langsamer als die meisten *Compilersprachen* und schneller als die meisten *Interpretersprachen*.

## C
- **C:** Verbreitete, sehr Hardware-nahe, feature-arme Programmiersprache. Wohl die Basis moderner Programmiersprachen. *Compiler*-Sprache. *Prozedural*, *funktional* orientiert. 
- **C++:** Wie C, zusätzlich mit mehr Elementen der *objektorientierten* Programmierung. Inzwischen verbreiteter als *C*. Insbesondere im grafikintensiven, rechenintensiven und hardwarenahen Bereich der Standard wegen hoher Geschwindigkeit. Zum Beispiel bei Spielen zum Beispiel *Unreal-Engine*). 
- **C#:** Sehr verbreitete Programmiersprache. Sehr objektorientiert. Bedeutung heutzutage vor allem durch Microsoft (*Visual Studio*). *Cross-platform* mit *Xamarin*.
 **Class:** Siehe *Klasse*.
- **Closed Test:** *Testing* mit einer geschlossenen / begrenzten Nutzergruppe, insbesondere einer Gruppe möglicher zukünftiger Nutzer. 
- **Compiler:** Programmiertool, das den Rohcode nimmt und ihn in maschinenlesbare Sprache umwandelt, damit es dann von dem Rechner ausgeführt werden kann. Dieses geschieht plattformabhängig, also der gleiche Rohcode führt auf verschiedenen Plattformen zu unterschiedlicher Maschinenensprache. Compilersprachen sind immer schneller als *Interpretersprachen*.
- **Compilersprache:** Programmiersprachen, deren Rohcode durch einen *Compiler* gejagt wird, um dann ausführbar zu sein.
- **Compiling:** Prozess des *Kompilieren* durch einen *Compiler*.
- **Coprozessor:** Zusätzlicher Mikroprozessor im Rechner, der den Hauptprozessor bei seiner Arbeit unterstützt. Koprozessoren können bspw. mathematische 
sowie Gleitkomma-Operationen, Grafikoperationen, Signalverarbeitung, I/O-Verarbeitung oder Kryptographie ausführen.
- **CPU (Central Processing Unit):** Zentraler Rechenkern des Computers. Bestimmt maßgeblich, wie schnell alle Operationen ausgeführt werden (zusammen mit der Geschwindigkeit, mit der er per Datenbus mit Daten gefüttert wird).
- **Cross platform:** (Angestrebte) Eigenschaft mehrerer Programmiersprachen und Tools, um plattformunabhägig programmieren zu können.

## D
- **Dart:** Von Google entwickelte allgemeine, *objektorientierte* Programmiersprache. Im Einsatz seit 2015. Ähnlichkeiten zu *Java*, *JavaScript*. Bekam massiven Schub durch *Flutter*. Weiterer Schub erwartet durch *Fuchsia*, das auf Dart basieren soll. 
- **Datenbus:** Sytem / Infrastruktur zur Datenübertragung zwischen den Komponenten eines Rechners. Häufig die Datenübertragung zwischen *CPU* und *RAM*.
- **DDR-RAM:** Eigentlich DDR-SDRAM. Seit 1999 gebräuchlicher Standard für RAM-Module. Die Bezeichnung "Double Data Rate Synchronous Dynamic Random Access Memory" bezieht sich darauf, dass damals (1999) die neue Bauart von RAM-Modulen technisch eine Verdopplung der Geschwindigkeit ermöglichte. Seitdem wurden 
stetig neue DDR-Standards rausgebracht. Aktuell stehen wir DDR5. Und wie bei jeder technischen Entwicklung: Mehr ist besser.
- **Debugger:** Komponente einer *Entwicklungsumgebung* (z.B. *IDE*), die beim Suchen von *Bugs* behilflich ist, in der Regel dadurch, dass man den Code schrittweise nachvollziehen/ beobachten kann. 
- **Deklarative Programmierung:** *Programmierparadigma*. Statt der Abfolge von Schritten zur Lösung eines Problems geht es eher um die Beschreibung des Problems und der Ausgangsbedingungen und der Computer soll den Weg dann selbständig finden. In der Praxis nicht allzu relevant, eher im akademischen Bereich zuhause.

## E
- **Entwicklungsumgebung:** Sammlung von Werkzeugen / Programmen, die beim Programmieren nützlich sind, was vieles umfassen mag, aber wohl zumindest Texteditor, *Compiler* bzw. *Interpreter*, *Debugger*. Sind diese und andere Tools in einem Programm vereint, spricht man von einer integrierten Entwicklungsumgebung (*IDE*)
- **Enum:** Datentyp in mehreren Programmsprachen. Enumeration bedeutet Aufzählung. Mit anderen Worten: Es gibt einen bestimmbare Anzahl von Werten. Diese sind aber nicht zwingend Zahlen. Beispiel: Ein Urlaubstag kann "Jahresurlaub", "Sonderurlaub" oder "Überstundenausgleich" sein. Man legt die möglichen Werte einmal im Code fest und kann dann mit diesen Begriffen arbeiten. Gegenüber einer Codierung in Zahlen macht es den Code für uns Menschen einfacher lesbar.
- **EXOR:** *Boolesche / Logische Operation*. Eine EXOR-Operation (manchamel auch XOR) ergibt true, wenn genau einer der Operanden true ist. Folglich: 1 XOR 1 = 0. 1 XOR 0 = 1, 0 XOR 1 = 1, 0 XOR 0 = 0.

## F
- **Fix:** Behebung eines *Bugs*.
- **Flutter:** Framework zur Architektur von Apps und insbesondere zur plattformunabhängigen Beschreibung von *GUI*-Elementen. Von Google entwickelt. Mit Flutter (und der damit automatischen Programmiersprache *Dart*) entwickelte Programme können kompiliert werden in *Java* / *Kotlin* (für *Android*), *Objective-C* / *Swift* (für *iOS*)
- **Fuchsia:** Unveröffentlichtes, geplantes eigenes PC-Betriebssystem von Google.
- **Funktion:** Baustein von Programmen. Eine Funktion bündelt Funktionalität, um Code nicht mehrfach schreiben zu können. Im genauen Wortsinne der Baustein *funktionaler* und *prozeduraler* Programmierung. In der objektorientierten Programmierung spricht man stattdessen von *Methoden*, die aber im Wesentlichen Funktionen gleichen. Kann einen / mehrere *Rückgabewert*(e) produzieren.
- **Funktionale Programmierung:** *Programmiersparadigma*. Ehrlich gesagt ohne Relevanz. Eher akademisch.

## G
- **GIT:** Software-Versionierungs- und Sicherungs-System. Legt eine lokales "Repository" an, in dem alle Zwischenstände gespeichert sind. Remote-Repositories sind ebenfalls möglich, also die Sicherung auf Servern. Erleichtert insbesondere die Zusammenarbeit an Software im Team durch Tools wie *Rebasing*. Ein paar ausführlichere Bemerkungen gibt es [hier](https://github.com/AUSoftAndreas/students/wiki/GIT-Vokabeln).
- **Grafikkarte:** Komponente eines PC zur Berechnung der Grafikausgabe, insbesondere von 3D-Grafiken. Hauptelemente sind ein *Grafikprozessor* (*GPU*) und eigenes, dezidiertes (nur für die Grafikkarte verwendetes) *RAM*.
- **Grafikprozessor:**: Siehe *GPU*.
- **GPU:** Graphics Processing Unit. Grafikprozessor. Hauptelement einer *Grafikkarte*.
- **GUI:** Graphical User Interface, also die (grafisch dargestellte) Benutzeroberfläche. Stellt den *State* dar und lässt Interaktionen mit dem *State* durch User zu.

## I
- **IDE:** x Siehe auch [Wiki-Artikel zu dem Thema](https://github.com/AUSoftAndreas/students/wiki/IDE---Integrated-Development-Environment).
- **Imperative Programmierung:** *Programmierparadigma*. Grundgedanke: "Mach das, dann das, dann das". Klassischer Einstieg in die Programmierung. Jede Zeile dreht sich um die Frage "wie löse ich das Problem und was mache ich dann?". Wurde nach und nach erweitert in Richtung *strukturierte Programmierung* und *prozedurale Programmierung*. Wirkliche Unterschiede gibt es zur *objektorientierten Programmierung* und zur *deklarativen Programmierung*.
- **Integration Test:** Systematisches *Testing* des Zusammenspiels von mehreren Komponenten, insbesondere *Klassen*.
- **Interpreter:** x
- **Interpretersprache:** x
- **iOS:** Betriebssystem von Apple, insbesondere für Mobilgeräte. Letztlich eine etwas abgespeckte Variante von *macOS*.

## J
- **Java:** Weit verbreitete *objektorientierte* Programmiersprache. *Compiliert* zu *Bytecode*, nutzt dann ein plattformspezifisches *Runtime* Environment, womit der *Bytecode* plattformunabhängig ist. Bekam massiven Schub durch Android, da Apps für Android in Java programmiert werden mussten. Verliert zurzeit Bedeutung durch *Kotlin*, *JavaScript*, *Dart* / *Flutter*.
- **JavaScript:** Weit verbreitete, freie Programmiersprache. Eigentlich objektiv schlechtere Sprache als viele andere, aber von Anfang an die Programmiersprache des WWW. Dadurch in jedem Browser, dadurch auf jedem Gerät. Bekam weitere Schübe durch *ReactJS*, *Node.JS*. Deutlich verbessert durch *TypeScript*. 

## K
- **KibiByte:** x
- **Kilobyte:** x
- **Klasse:** x
- **Kompilierung:** Siehe *Compiling*.
- **Kotlin:** Moderne Programmiersprache, lose basierend auf *Java*. Inzwischen offizielle Programmiersprache für Android, hat *Java* diesbezüglich abgelöst.

## L
- **Linter:** Komponente einer *IDE*, die dafür sorgt, dass nicht nur Fehler angezeigt werden, sondern auch Hinweise zur optimierten Programmierung.
- **Logikfehler:** *Bug*, der durch einen falschen Algorithmus bzw. falsche Überlegungen beim Programmieren verursacht ist, also nicht durch Fehler in der *Syntax*. Folglich in der Regel keine Fehlermeldungen, sondern eher unerwartete Ergebnisse. Schwerer zu lokalisieren und zu *fixen* als *Syntaxfehler*

# M
- **MacOS:** Betriebssystem von Apple für den Einsatz in deren Desktopsystemen.
- **Megabit:** x
- **Megabyte:** x
- **Mibibyte:** x


## N
- **Netzteil:** Komponente des Computers, das den aus Wechselstrom aus der Steckdose in den vom Computer benötigten Wechselstrom umwandelt. [Wiki-Artikel zu dem Thema.](https://github.com/AUSoftAndreas/students/wiki/Stichwort-Netzteil)
- **Node.js:** x
- **NOT:** *Boolesche / Logische Operation*. Eine NOT-Operation kehrt den Wert eines *Booleschen Wert* um. FOLGLICH NOT 1 = 0. NOT 0 = 1.

## O
- **Objective-C:** Programmiersprache. Erweiterung von *C*, insbesondere hinsichtlich der *objektorientierten Programmierung*. Bedeutung insbesondere dadurch, dass es eine der beiden nativen Programmiersprachen für *iOS* ist.
- **Objektorientierte Programmierung:** x
- **Open Test:** Siehe *Public Test*.
- **OR:** *Boolesche / Logische Operation*. Eine OR-Operation ergibt true, wenn mindestens einer der Operanden true ist. Folglich: 1 OR 1 = 1. 1 OR 0 = 1, 0 OR 1 = 1, 0 OR 0 = 0.

## P
- **Pointer:** Verweis auf einen Speicherbereich. Manche, besonders maschinennahe Sprachen, lassen die direkte Manipulation von Speicherbereichen zu. Allgemeiner gesprochen kann Pointer auch als synonym mit *Referenz* verwendet werden.
- **Programmierparadimen:** x
- **Prozedurale Programmierung:** *Programmierparadigma*: Aufspaltung von Aufgaben in kleinere Teilaufgaben. Schreiben von *Funktionen*, welche diese 
Teilaufgabe lösen. Zusammenführung der Ergebnisse. Im Kern das, was wohl der klassische Einstieg in Programmierung heutzutage ist.
- **Public Test:** *Testing* mit / durch eine prinzipiell nicht begrenzte Nutzergruppe, die in der Regel den zukünftigen Nutzern entspricht.

## R
- **RAM:** x
- **React JS:** x
- **Referenz:** Verweis auf eine *Variable*, nicht auf ihren Inhalt. Manche Sprachen unterscheiden zwischen zwei Arten davon, eine Variable als *Argument* an eine Funktion zu übergeben, nämlich der Übergabe als Wert (byVal zum Beispiel in *Visual Basic*) und als Referenz (byRef). Beispielsweise in *PHP* wird diesbezüglich per *Prefix* klar gemacht, wenn eine Übergabe per Referenz geschehen soll. Das hat zur Folge, dass die aufgerufene *Funktion* direkten Zugriff auf den Speicherbereich der Variable bekommt. Ändert sie also den Wert der Variable, dann ist dieser Wert auch für die aufrufende Funktion danach verändert. Bei einer Übergabe des Wertes hingegen, wird eigentlich eine Kopie der *Variable* übergeben. Ändert sich der Wert dieser *Variable* in der aufgerufenen *Funktion*, hat das keine Wirkung auf die aufrufende *Funktion*. Die aufrufende *Funktion* erhält von der aufgerufenen *Funktion* gegebenenfalls einen *Rückgabewert*, aber sonst keine Auswirkungen.
- **Release:** 
- **Rendern:** Optische Darstellung von Bildern oder *GUI*-Elementen.
- **Runtime:** ycxyx
- **Rückgabewert:** *Funktionen* haben zumeist ein Ergebnis ihrer Operation. Dieser Wert kann dann dort, wo die *Funktion* aufgerufen werden, weiter verwendet werden. Ein besonderer Rückgabewert ist *void*, was in den meisten Sprachen darauf hinweist, dass es keinen Rückgabewert gibt. Die *Funktion* läuft aus Sicht der aufrufenden *Funktion* ab, tut dabei irgendwas - wirkt aber sonst nicht zurück in die aufrufende Funktion.


## S
- **Strukturierte Programmierung:** *Programmierparadigma*. Eher historisch interessant. Anweisungen wie "if then" und "while do" lösten die Möglichkeit ab, zum Beispiel per "goto" einfach irgendwohin im Code zu springen. Code wurde so übersichtlicher.
- **Swift:** Programmiersprache. Open Source, aber vor allem entwickelt von Apple. Bedeutung insbesondere dadurch, dass es eine der beiden nativen Programmiersprachen für *iOS* ist.
- **Syntax:** Grammatik und Vokabular einer Programmiersprache, also alle Regeln, die man beachten muss, damit der Code prinzipiell vom Computer verstanden wird.
- **Syntaxfehler:** *Bug*, der im Wesentlichen daher kommt, dass der Programmierer sich vertippte oder andere Regeln der Programmiersprache nicht beachtete. Einfacher zu *fixen* als *Logikfehler*.

## T
- **Testing:** Systematisches Testen einer Software und ihrer Komponenten, siehe *Unit Test*, *Integration Test*, *Closed Test*, *Open / Public Test*, *Alpha Test*, *Beta Test*, *Black Box Test*, *White Box Test*.
- **Typescript:** x

## U
- **Unit Test:** Systematisches *Testing* einer einzelnen *Klasse*, *Methode* oder *Funktion*.
- **Unity Engine:** x
- **Unreal Engine:** x

## V
- **Visual Studio:** *IDE* von Microsoft, vor allem spezialisiert auf *C#*.
- **Visual Studio Code:** "Kleiner" Bruder von Visual Studio. Weniger Umfang, weniger spezialisiert. Erweiterbar durch *Plugins*.

## X
- **x86:** x
- **Xamarin:** Framework zur Erstellung von *cross-platform* Software. Basis ist C#, *Visual Studio*.
- **XOR:** Siehe *EXOR*.

## W
- **White Box Test:** Form des *Testing*, bei dem bewusst anhand / entlang bzw. Unter Kenntnis des Codes getestet wird. Extremform: *Testing* mit einem *Debugger*.